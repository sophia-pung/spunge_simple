{% comment %}
    Aurora Hero Section
    Full-screen WebGL Aurora Borealis background with navigation
{% endcomment %}

<!-- Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400&family=Libre+Baskerville:wght@400;700&display=swap" rel="stylesheet">

<!-- Loading Screen -->
<div class="loading" id="loading">
    <span class="loading-text">loading</span>
</div>

<!-- Aurora Canvas Background -->
<canvas id="aurora-canvas"></canvas>

<!-- Navigation -->
<div class="nav-container">
    <nav>
        <a href="{{ pages['about'].url | default: '/pages/about' }}">About</a>
        <a href="{{ pages['launch'].url | default: '/pages/launch' }}">Launch</a>
        <a href="{{ routes.all_products_collection_url | default: '/collections/all' }}">Shop</a>
    </nav>
</div>

<!-- Content Overlay with Brand Title -->
<div class="content-overlay">
    <h1 class="brand-title">SPoNGe</h1>
</div>

<style>
    :root {
        --sponge-bg: #0a0a0f;
        --sponge-violet: #9B8FD9;
        --sponge-white: #F5F5F5;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    .aurora-hero-section {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        font-family: 'Libre Baskerville', Georgia, serif;
        background: var(--sponge-bg);
        display: block;
    }

    /* Loading Screen */
    .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: var(--sponge-bg);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 1s ease, visibility 1s ease;
    }

    .loading.fade-out {
        opacity: 0;
        visibility: hidden;
    }

    .loading-text {
        font-size: 1rem;
        letter-spacing: 0.3em;
        color: var(--sponge-violet);
        text-transform: lowercase;
        animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 0.4; }
        50% { opacity: 1; }
    }

    /* Canvas */
    #aurora-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
    }

    /* Navigation */
    .nav-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100;
        padding: 2rem 3rem;
    }

    nav {
        display: flex;
        justify-content: center;
        gap: 4rem;
    }

    nav a {
        font-family: 'Libre Baskerville', Georgia, serif;
        font-size: 0.9rem;
        letter-spacing: 0.15em;
        text-decoration: none;
        color: var(--sponge-white);
        opacity: 0.8;
        transition: opacity 0.3s ease;
        text-transform: lowercase;
    }

    nav a:hover {
        opacity: 1;
    }

    /* Content Overlay */
    .content-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
    }

    /* Brand Title */
    .brand-title {
        font-family: 'Cormorant Garamond', Georgia, serif;
        font-size: clamp(3rem, 10vw, 8rem);
        font-weight: 300;
        color: #FFFFFF;
        letter-spacing: 0.2em;
        text-align: center;
        opacity: 0;
        animation: titleFadeIn 2s ease 0.5s forwards;
        text-shadow: 0 0 60px rgba(155, 143, 217, 0.3);
    }

    @keyframes titleFadeIn {
        0% {
            opacity: 0;
            transform: translateY(20px);
        }
        100% {
            opacity: 0.95;
            transform: translateY(0);
        }
    }

    @media (max-width: 768px) {
        nav {
            gap: 2rem;
        }

        nav a {
            font-size: 0.8rem;
        }

        .brand-title {
            font-size: clamp(2rem, 14vw, 4rem);
            letter-spacing: 0.15em;
        }
    }
</style>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // ============================================
    // AURORA BOREALIS VERTEX SHADER
    // ============================================
    const vertexShader = `
        varying vec2 vUv;
        
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // ============================================
    // AURORA BOREALIS FRAGMENT SHADER
    // ============================================
    const fragmentShader = `
        precision highp float;
        
        uniform vec2 resolution;
        uniform float time;
        
        uniform vec3 auroraColor;
        uniform float noiseTiling;
        uniform vec2 noiseSpeed;
        uniform float noisePower;
        uniform float noiseScale;
        uniform float auroraIntensity;
        
        varying vec2 vUv;
        
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }
        
        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                               -0.577350269189626, 0.024390243902439);
            
            vec2 i  = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            
            i = mod289(i);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                            + i.x + vec3(0.0, i1.x, 1.0));
            
            vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),
                                    dot(x12.zw, x12.zw)), 0.0);
            m = m * m;
            m = m * m;
            
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            
            m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
            
            vec3 g;
            g.x = a0.x * x0.x + h.x * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            
            return 130.0 * dot(m, g);
        }
        
        float auroraCurtain(vec2 uv, float timeOffset) {
            float wave1 = sin(uv.x * 3.0 + time * 0.3 + timeOffset) * 0.1;
            float wave2 = sin(uv.x * 7.0 - time * 0.2 + timeOffset * 2.0) * 0.05;
            float wave3 = sin(uv.x * 13.0 + time * 0.4 + timeOffset * 0.5) * 0.02;
            
            float verticalWave = wave1 + wave2 + wave3;
            
            vec2 animatedUV = uv;
            animatedUV.x += time * noiseSpeed.x;
            animatedUV.y += time * noiseSpeed.y + verticalWave;
            
            float noise1 = snoise(animatedUV * noiseTiling);
            float noise2 = snoise(animatedUV * noiseTiling * 2.0 + vec2(100.0, 0.0));
            float noise3 = snoise(animatedUV * noiseTiling * 0.5 + vec2(0.0, 50.0));
            
            float combinedNoise = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;
            combinedNoise = pow(abs(combinedNoise), noisePower);
            
            return combinedNoise;
        }
        
        float mountainShape(vec2 uv) {
            float x = uv.x;
            
            float mountain1 = 0.08 + 0.05 * sin(x * 3.5) + 0.025 * sin(x * 8.0 + 1.0);
            float mountain2 = 0.06 + 0.04 * sin(x * 5.0 + 2.0) + 0.02 * sin(x * 12.0);
            float mountain3 = 0.10 + 0.06 * sin(x * 2.0 - 1.0) + 0.03 * sin(x * 6.0 + 0.5);
            
            float rockNoise = snoise(vec2(x * 30.0, 0.0)) * 0.012;
            float detailNoise = snoise(vec2(x * 80.0, 0.0)) * 0.005;
            
            float mountainHeight = max(max(mountain1, mountain2), mountain3) + rockNoise + detailNoise;
            float mountainMask = smoothstep(mountainHeight + 0.008, mountainHeight - 0.008, uv.y);
            
            return mountainMask;
        }
        
        void main() {
            vec2 uv = vUv;
            float aspect = resolution.x / resolution.y;
            
            vec3 backgroundColor = vec3(0.01, 0.01, 0.02);
            
            float stars = 0.0;
            vec2 starUV = uv * 200.0;
            float starNoise = snoise(starUV);
            if (starNoise > 0.85) {
                float twinkle = sin(time * 3.0 + starNoise * 100.0) * 0.5 + 0.5;
                stars = (starNoise - 0.85) * 6.0 * twinkle;
            }
            backgroundColor += vec3(stars * 0.5);
            
            float auroraHeight = smoothstep(0.3, 0.9, uv.y);
            float auroraFade = smoothstep(1.0, 0.7, uv.y);
            float verticalMask = auroraHeight * auroraFade;
            
            float aurora1 = auroraCurtain(uv, 0.0);
            float aurora2 = auroraCurtain(uv * 1.3 + vec2(0.5, 0.0), 1.5);
            float aurora3 = auroraCurtain(uv * 0.7 + vec2(-0.3, 0.1), 3.0);
            
            float auroraBase = aurora1 * 0.5 + aurora2 * 0.3 + aurora3 * 0.2;
            
            float streakNoise = snoise(vec2(uv.x * 30.0 + time * 0.1, time * 0.05));
            float streaks = pow(abs(streakNoise), 3.0) * 0.5;
            auroraBase += streaks * verticalMask;
            
            float aurora = auroraBase * verticalMask;
            
            vec3 normalizedColor = auroraColor / 300.0;
            
            float colorShift = snoise(uv * 2.0 + time * 0.1) * 0.3;
            
            vec3 color1 = normalizedColor;
            vec3 color2 = vec3(normalizedColor.r * 1.2, normalizedColor.g * 0.8, normalizedColor.b * 0.9);
            vec3 color3 = vec3(normalizedColor.r * 0.5, normalizedColor.g * 0.9, normalizedColor.b * 1.1);
            
            vec3 auroraColor1 = mix(color1, color2, smoothstep(-0.3, 0.3, colorShift));
            vec3 finalAuroraColor = mix(auroraColor1, color3, smoothstep(0.2, 0.5, colorShift + uv.x * 0.3));
            
            vec3 color = backgroundColor;
            color += finalAuroraColor * aurora * auroraIntensity;
            
            float glowMask = smoothstep(0.2, 0.8, uv.y) * smoothstep(1.0, 0.6, uv.y);
            vec3 atmosphericGlow = normalizedColor * 0.15 * glowMask * (0.5 + aurora * 0.5);
            color += atmosphericGlow;
            
            float mountain = mountainShape(uv);
            vec3 mountainColor = vec3(0.02, 0.015, 0.025);
            float edgeGlow = smoothstep(0.0, 0.05, uv.y - 0.1) * (1.0 - smoothstep(0.1, 0.25, uv.y));
            mountainColor += normalizedColor * 0.05 * edgeGlow * aurora;
            color = mix(color, mountainColor, mountain);
            
            float vignette = 1.0 - length((uv - 0.5) * vec2(1.0, 0.8)) * 0.3;
            color *= vignette;
            
            color = color / (color + vec3(1.0));
            color = pow(color, vec3(0.95));
            
            gl_FragColor = vec4(color, 1.0);
        }
    `;

    // THREE.JS SETUP
    const canvas = document.getElementById('aurora-canvas');
    if (canvas) {
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const uniforms = {
            resolution: { value: new THREE.Vector2() },
            time: { value: 0.0 },
            auroraColor: { value: new THREE.Vector3(303.55, 297.16, 766.99) },
            noiseTiling: { value: 3.0 },
            noiseSpeed: { value: new THREE.Vector2(-0.01, -0.04) },
            noisePower: { value: 1.4 },
            noiseScale: { value: 500.0 },
            auroraIntensity: { value: 2.5 }
        };

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms
        });
        const quad = new THREE.Mesh(geometry, material);
        scene.add(quad);

        function resize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(pixelRatio);
            uniforms.resolution.value.set(width * pixelRatio, height * pixelRatio);
        }

        window.addEventListener('resize', resize);
        resize();

        function animate(time) {
            uniforms.time.value = time * 0.001;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

        // Hide loading screen
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.classList.add('fade-out');
                setTimeout(() => { loading.style.display = 'none'; }, 1000);
            }
        }, 500);
    }
</script>

{% schema %}
{
    "name": "Aurora Hero",
    "tag": "section",
    "class": "aurora-hero-section",
    "settings": [
        {
            "type": "checkbox",
            "id": "show_title",
            "label": "Show Title",
            "default": false
        },
        {
            "type": "text",
            "id": "title",
            "label": "Title",
            "default": "SPoNGe"
        }
    ],
    "presets": [
        {
            "name": "Aurora Hero"
        }
    ]
}
{% endschema %}

